#!/usr/bin/env python
"""
Content Management System Integration Module

This module provides integration between the CMS and existing academic agent systems,
including the main agent, consolidation agent, and quality management systems.
"""

import os
import sys
import json
import logging
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
from datetime import datetime
import uuid

from .content_management_system import (
    ContentManagementSystem, CourseInfo, ContentItem, ContentType,
    ProcessingStatus, ProcessingRecord
)
from .base_agent import BaseAgent, AgentMessage
from .consolidation_agent import ContentConsolidationAgent
from .quality_manager import QualityManager
from .main_agent import MainAcademicAgent


class CMSIntegration(BaseAgent):
    """Integration layer between CMS and existing academic agent systems"""
    
    def __init__(self, base_path: str, config: Dict[str, Any] = None):
        super().__init__("cms_integration")
        
        self.base_path = Path(base_path)
        self.config = config or {}
        
        # Initialize CMS
        self.cms = ContentManagementSystem(str(self.base_path), config)
        
        # Initialize existing systems
        self.consolidation_agent = ContentConsolidationAgent()
        self.quality_manager = QualityManager()
        
        # Integration flags
        self.auto_import_enabled = self.config.get('auto_import_enabled', True)
        self.auto_quality_check = self.config.get('auto_quality_check', True)
        self.auto_relationship_detection = self.config.get('auto_relationship_detection', True)
        
        self.logger.info(\"CMS Integration initialized\")\n    \n    def integrate_with_main_agent(self, main_agent: 'MainAcademicAgent') -> bool:\n        \"\"\"Integrate CMS with the main academic agent\"\"\"\n        try:\n            # Set up message handlers for CMS operations\n            main_agent.cms_integration = self\n            \n            # Register CMS-specific message types\n            cms_message_types = [\n                \"content_import_request\",\n                \"content_search_request\", \n                \"quality_assessment_request\",\n                \"relationship_detection_request\",\n                \"analytics_request\"\n            ]\n            \n            # Add CMS capabilities to main agent\n            main_agent.capabilities.extend([\n                \"content_management\",\n                \"search_and_discovery\",\n                \"relationship_mapping\",\n                \"quality_assessment\",\n                \"content_analytics\"\n            ])\n            \n            self.logger.info(\"Successfully integrated with main academic agent\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Failed to integrate with main agent: {str(e)}\")\n            return False\n    \n    def process_content_import_request(self, request: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Process content import request from main agent\"\"\"\n        try:\n            course_id = request.get('course_id')\n            source_paths = request.get('source_paths', [])\n            content_type = request.get('content_type')\n            \n            if not course_id or not source_paths:\n                return {\n                    'success': False,\n                    'error': 'Missing required parameters: course_id or source_paths'\n                }\n            \n            # Check if course exists, create if not\n            course = self.cms.get_course(course_id)\n            if not course:\n                # Auto-create course with minimal info\n                course = CourseInfo(\n                    course_id=course_id,\n                    course_name=request.get('course_name', f'Course {course_id}'),\n                    course_code=request.get('course_code', course_id),\n                    academic_year=request.get('academic_year', str(datetime.now().year)),\n                    semester=request.get('semester', 'Unknown'),\n                    instructor=request.get('instructor', 'Unknown'),\n                    department=request.get('department', 'Unknown')\n                )\n                \n                success = self.cms.create_course(course)\n                if not success:\n                    return {\n                        'success': False,\n                        'error': f'Failed to create course: {course_id}'\n                    }\n            \n            # Import content using consolidation agent\n            consolidation_result = self.cms.consolidate_content(source_paths, course_id)\n            \n            # Process imported content\n            processed_content = []\n            for mapping in consolidation_result.processed_files:\n                # Perform quality assessment if enabled\n                content_id = None\n                \n                # Find the content item that was created from this mapping\n                content_items = self.cms.list_content(course_id=course_id)\n                for item in content_items:\n                    if item.file_path == mapping.source_path:\n                        content_id = item.content_id\n                        break\n                \n                if content_id and self.auto_quality_check:\n                    quality_evaluation = self.cms.quality_assessment(content_id)\n                    \n                    if quality_evaluation:\n                        processed_content.append({\n                            'content_id': content_id,\n                            'file_path': mapping.source_path,\n                            'quality_score': quality_evaluation.quality_score,\n                            'approved': quality_evaluation.approved\n                        })\n                \n                # Detect relationships if enabled\n                if content_id and self.auto_relationship_detection:\n                    relationships = self.cms.detect_relationships(content_id)\n                    \n                    if processed_content:\n                        processed_content[-1]['relationships_detected'] = len(relationships)\n            \n            # Build search index for new content\n            self.cms.build_search_index()\n            \n            return {\n                'success': consolidation_result.success,\n                'processed_files': len(consolidation_result.processed_files),\n                'skipped_files': len(consolidation_result.skipped_files),\n                'errors': consolidation_result.errors,\n                'processed_content': processed_content,\n                'course_id': course_id\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error processing content import request: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    def process_content_search_request(self, request: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Process content search request\"\"\"\n        try:\n            query = request.get('query')\n            if not query:\n                return {\n                    'success': False,\n                    'error': 'Missing required parameter: query'\n                }\n            \n            course_id = request.get('course_id')\n            content_type = request.get('content_type')\n            week_number = request.get('week_number')\n            limit = request.get('limit', 20)\n            \n            # Parse content type\n            content_type_enum = None\n            if content_type:\n                try:\n                    content_type_enum = ContentType(content_type)\n                except ValueError:\n                    pass\n            \n            # Perform search\n            search_results = self.cms.search_content(\n                query=query,\n                course_id=course_id,\n                content_type=content_type_enum,\n                week_number=week_number,\n                limit=limit\n            )\n            \n            # Format results\n            formatted_results = []\n            for content_item, relevance_score in search_results:\n                result = {\n                    'content_id': content_item.content_id,\n                    'title': content_item.title,\n                    'content_type': content_item.content_type.value,\n                    'course_id': content_item.course_id,\n                    'week_number': content_item.week_number,\n                    'relevance_score': relevance_score,\n                    'quality_score': content_item.quality_score,\n                    'file_path': content_item.file_path,\n                    'description': content_item.description\n                }\n                formatted_results.append(result)\n            \n            return {\n                'success': True,\n                'query': query,\n                'results_count': len(formatted_results),\n                'results': formatted_results\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error processing search request: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    def process_quality_assessment_request(self, request: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Process quality assessment request\"\"\"\n        try:\n            content_id = request.get('content_id')\n            course_id = request.get('course_id')\n            \n            if not content_id and not course_id:\n                return {\n                    'success': False,\n                    'error': 'Missing required parameter: content_id or course_id'\n                }\n            \n            assessments = []\n            \n            if content_id:\n                # Assess specific content\n                evaluation = self.cms.quality_assessment(content_id)\n                if evaluation:\n                    assessments.append({\n                        'content_id': content_id,\n                        'quality_score': evaluation.quality_score,\n                        'approved': evaluation.approved,\n                        'feedback': evaluation.feedback,\n                        'areas_for_improvement': evaluation.areas_for_improvement,\n                        'strengths': evaluation.strengths\n                    })\n            \n            elif course_id:\n                # Assess all content in course\n                content_items = self.cms.list_content(course_id=course_id)\n                \n                for item in content_items:\n                    evaluation = self.cms.quality_assessment(item.content_id)\n                    if evaluation:\n                        assessments.append({\n                            'content_id': item.content_id,\n                            'title': item.title,\n                            'content_type': item.content_type.value,\n                            'quality_score': evaluation.quality_score,\n                            'approved': evaluation.approved,\n                            'feedback': evaluation.feedback\n                        })\n            \n            # Calculate summary statistics\n            if assessments:\n                total_assessed = len(assessments)\n                total_approved = sum(1 for a in assessments if a['approved'])\n                avg_quality = sum(a['quality_score'] for a in assessments) / total_assessed\n                \n                summary = {\n                    'total_assessed': total_assessed,\n                    'total_approved': total_approved,\n                    'approval_rate': total_approved / total_assessed,\n                    'average_quality_score': avg_quality\n                }\n            else:\n                summary = {\n                    'total_assessed': 0,\n                    'total_approved': 0,\n                    'approval_rate': 0.0,\n                    'average_quality_score': 0.0\n                }\n            \n            return {\n                'success': True,\n                'assessments': assessments,\n                'summary': summary\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error processing quality assessment request: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    def process_relationship_detection_request(self, request: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Process relationship detection request\"\"\"\n        try:\n            content_id = request.get('content_id')\n            course_id = request.get('course_id')\n            \n            if not content_id and not course_id:\n                return {\n                    'success': False,\n                    'error': 'Missing required parameter: content_id or course_id'\n                }\n            \n            detected_relationships = []\n            \n            if content_id:\n                # Detect relationships for specific content\n                relationships = self.cms.detect_relationships(content_id, auto_create=True)\n                \n                for rel in relationships:\n                    detected_relationships.append({\n                        'relationship_id': rel.relationship_id,\n                        'source_content_id': rel.source_content_id,\n                        'target_content_id': rel.target_content_id,\n                        'relationship_type': rel.relationship_type,\n                        'strength': rel.strength,\n                        'description': rel.description,\n                        'auto_detected': rel.auto_detected\n                    })\n            \n            elif course_id:\n                # Detect relationships for all content in course\n                content_items = self.cms.list_content(course_id=course_id)\n                \n                for item in content_items:\n                    relationships = self.cms.detect_relationships(item.content_id, auto_create=True)\n                    \n                    for rel in relationships:\n                        detected_relationships.append({\n                            'relationship_id': rel.relationship_id,\n                            'source_content_id': rel.source_content_id,\n                            'target_content_id': rel.target_content_id,\n                            'relationship_type': rel.relationship_type,\n                            'strength': rel.strength,\n                            'description': rel.description,\n                            'auto_detected': rel.auto_detected\n                        })\n            \n            # Generate relationship statistics\n            if detected_relationships:\n                relationship_types = {}\n                for rel in detected_relationships:\n                    rel_type = rel['relationship_type']\n                    relationship_types[rel_type] = relationship_types.get(rel_type, 0) + 1\n                \n                avg_strength = sum(rel['strength'] for rel in detected_relationships) / len(detected_relationships)\n                auto_detected_count = sum(1 for rel in detected_relationships if rel['auto_detected'])\n                \n                statistics = {\n                    'total_relationships': len(detected_relationships),\n                    'relationship_types': relationship_types,\n                    'average_strength': avg_strength,\n                    'auto_detected_count': auto_detected_count,\n                    'manual_count': len(detected_relationships) - auto_detected_count\n                }\n            else:\n                statistics = {\n                    'total_relationships': 0,\n                    'relationship_types': {},\n                    'average_strength': 0.0,\n                    'auto_detected_count': 0,\n                    'manual_count': 0\n                }\n            \n            return {\n                'success': True,\n                'relationships': detected_relationships,\n                'statistics': statistics\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error processing relationship detection request: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    def process_analytics_request(self, request: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Process analytics report request\"\"\"\n        try:\n            course_id = request.get('course_id')\n            start_date = request.get('start_date')\n            end_date = request.get('end_date')\n            \n            # Parse dates if provided\n            start_datetime = None\n            end_datetime = None\n            \n            if start_date:\n                if isinstance(start_date, str):\n                    start_datetime = datetime.fromisoformat(start_date)\n                else:\n                    start_datetime = start_date\n            \n            if end_date:\n                if isinstance(end_date, str):\n                    end_datetime = datetime.fromisoformat(end_date)\n                else:\n                    end_datetime = end_date\n            \n            # Generate analytics report\n            report = self.cms.generate_analytics_report(\n                course_id=course_id,\n                start_date=start_datetime,\n                end_date=end_datetime\n            )\n            \n            if report:\n                return {\n                    'success': True,\n                    'report': report\n                }\n            else:\n                return {\n                    'success': False,\n                    'error': 'Failed to generate analytics report'\n                }\n            \n        except Exception as e:\n            self.logger.error(f\"Error processing analytics request: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    def handle_agent_message(self, message: AgentMessage) -> Dict[str, Any]:\n        \"\"\"Handle messages from other agents\"\"\"\n        try:\n            message_type = message.message_type\n            content = message.content\n            \n            if message_type == \"content_import_request\":\n                return self.process_content_import_request(content)\n            \n            elif message_type == \"content_search_request\":\n                return self.process_content_search_request(content)\n            \n            elif message_type == \"quality_assessment_request\":\n                return self.process_quality_assessment_request(content)\n            \n            elif message_type == \"relationship_detection_request\":\n                return self.process_relationship_detection_request(content)\n            \n            elif message_type == \"analytics_request\":\n                return self.process_analytics_request(content)\n            \n            else:\n                return {\n                    'success': False,\n                    'error': f'Unknown message type: {message_type}'\n                }\n            \n        except Exception as e:\n            self.logger.error(f\"Error handling agent message: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    def process_workflow_request(self, workflow_type: str, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Process complex workflow requests\"\"\"\n        try:\n            if workflow_type == \"full_content_processing\":\n                return self._process_full_content_workflow(parameters)\n            \n            elif workflow_type == \"course_setup\":\n                return self._process_course_setup_workflow(parameters)\n            \n            elif workflow_type == \"content_analysis\":\n                return self._process_content_analysis_workflow(parameters)\n            \n            else:\n                return {\n                    'success': False,\n                    'error': f'Unknown workflow type: {workflow_type}'\n                }\n            \n        except Exception as e:\n            self.logger.error(f\"Error processing workflow: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    def _process_full_content_workflow(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Process full content workflow: import, assess, index, detect relationships\"\"\"\n        course_id = parameters.get('course_id')\n        source_paths = parameters.get('source_paths', [])\n        \n        results = {\n            'course_id': course_id,\n            'steps': [],\n            'overall_success': True\n        }\n        \n        # Step 1: Import content\n        import_result = self.process_content_import_request({\n            'course_id': course_id,\n            'source_paths': source_paths\n        })\n        \n        results['steps'].append({\n            'step': 'content_import',\n            'success': import_result['success'],\n            'details': import_result\n        })\n        \n        if not import_result['success']:\n            results['overall_success'] = False\n            return results\n        \n        # Step 2: Quality assessment\n        quality_result = self.process_quality_assessment_request({\n            'course_id': course_id\n        })\n        \n        results['steps'].append({\n            'step': 'quality_assessment',\n            'success': quality_result['success'],\n            'details': quality_result\n        })\n        \n        # Step 3: Relationship detection\n        relationship_result = self.process_relationship_detection_request({\n            'course_id': course_id\n        })\n        \n        results['steps'].append({\n            'step': 'relationship_detection',\n            'success': relationship_result['success'],\n            'details': relationship_result\n        })\n        \n        # Step 4: Build search index\n        index_success = self.cms.build_search_index()\n        \n        results['steps'].append({\n            'step': 'search_index',\n            'success': index_success,\n            'details': {'index_built': index_success}\n        })\n        \n        return results\n    \n    def _process_course_setup_workflow(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Process course setup workflow\"\"\"\n        course_info = parameters.get('course_info')\n        \n        if not course_info:\n            return {\n                'success': False,\n                'error': 'Missing course_info parameter'\n            }\n        \n        # Create course\n        course = CourseInfo(**course_info)\n        success = self.cms.create_course(course)\n        \n        if success:\n            # Create default directory structure\n            course_storage_path = self.cms.storage_path / course.course_id\n            \n            default_dirs = [\n                'lectures', 'transcripts', 'notes', 'textbook',\n                'assignments', 'tutorials', 'exams', 'resources'\n            ]\n            \n            for dir_name in default_dirs:\n                dir_path = course_storage_path / dir_name\n                dir_path.mkdir(parents=True, exist_ok=True)\n            \n            return {\n                'success': True,\n                'course_id': course.course_id,\n                'directories_created': default_dirs\n            }\n        else:\n            return {\n                'success': False,\n                'error': f'Failed to create course: {course.course_id}'\n            }\n    \n    def _process_content_analysis_workflow(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Process content analysis workflow\"\"\"\n        course_id = parameters.get('course_id')\n        \n        if not course_id:\n            return {\n                'success': False,\n                'error': 'Missing course_id parameter'\n            }\n        \n        # Generate comprehensive analytics\n        analytics_result = self.process_analytics_request({'course_id': course_id})\n        \n        # Get relationship analysis\n        relationship_result = self.process_relationship_detection_request({'course_id': course_id})\n        \n        # Get quality analysis\n        quality_result = self.process_quality_assessment_request({'course_id': course_id})\n        \n        return {\n            'success': True,\n            'course_id': course_id,\n            'analytics': analytics_result.get('report', {}),\n            'relationships': relationship_result.get('statistics', {}),\n            'quality': quality_result.get('summary', {})\n        }\n    \n    def get_cms_status(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive CMS status\"\"\"\n        try:\n            # Get basic statistics\n            courses = self.cms.list_courses()\n            all_content = self.cms.list_content(limit=10000)  # Get all content\n            \n            # Content statistics by type\n            content_by_type = {}\n            content_by_status = {}\n            \n            for item in all_content:\n                content_type = item.content_type.value\n                status = item.processing_status.value\n                \n                content_by_type[content_type] = content_by_type.get(content_type, 0) + 1\n                content_by_status[status] = content_by_status.get(status, 0) + 1\n            \n            # Quality statistics\n            quality_items = [item for item in all_content if item.quality_score is not None]\n            avg_quality = sum(item.quality_score for item in quality_items) / len(quality_items) if quality_items else 0\n            \n            # Storage statistics\n            total_storage = sum(item.file_size for item in all_content)\n            \n            return {\n                'total_courses': len(courses),\n                'total_content': len(all_content),\n                'content_by_type': content_by_type,\n                'content_by_status': content_by_status,\n                'average_quality_score': avg_quality,\n                'total_storage_bytes': total_storage,\n                'total_storage_mb': total_storage / (1024 * 1024),\n                'cms_agent_status': self.get_agent_status()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting CMS status: {str(e)}\")\n            return {\n                'error': str(e)\n            }\n    \n    # Required BaseAgent methods\n    def validate_input(self, input_data: Any) -> bool:\n        \"\"\"Validate input data\"\"\"\n        return isinstance(input_data, dict)\n    \n    def validate_output(self, output_data: Any) -> bool:\n        \"\"\"Validate output data\"\"\"\n        return isinstance(output_data, dict)\n    \n    def check_quality(self, content: Any) -> float:\n        \"\"\"Check quality of integration operations\"\"\"\n        try:\n            # Basic health check\n            status = self.get_cms_status()\n            \n            if 'error' in status:\n                return 0.1\n            \n            # Quality based on content processing success\n            total_content = status.get('total_content', 0)\n            completed_content = status.get('content_by_status', {}).get('completed', 0)\n            \n            if total_content > 0:\n                completion_rate = completed_content / total_content\n                return min(0.9, 0.5 + (completion_rate * 0.4))\n            else:\n                return 0.7  # Default for empty system\n                \n        except Exception:\n            return 0.1\n    \n    def shutdown(self) -> None:\n        \"\"\"Shutdown the integration system\"\"\"\n        try:\n            self.cms.shutdown()\n            self.logger.info(\"CMS Integration shutdown complete\")\n        except Exception as e:\n            self.logger.error(f\"Error during integration shutdown: {str(e)}\")\n        \n        super().shutdown()\n\n\ndef create_integration_config() -> Dict[str, Any]:\n    \"\"\"Create default integration configuration\"\"\"\n    return {\n        'auto_import_enabled': True,\n        'auto_quality_check': True,\n        'auto_relationship_detection': True,\n        'cms': {\n            'database': {\n                'path': 'cms/content_database.db',\n                'backup_enabled': True\n            },\n            'storage': {\n                'base_path': 'cms/storage',\n                'versioning_enabled': True\n            },\n            'processing': {\n                'auto_index_content': True,\n                'batch_processing_size': 10\n            }\n        }\n    }\n\n\ndef main():\n    \"\"\"Main function for testing integration\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(description=\"CMS Integration Testing\")\n    parser.add_argument(\"--base-path\", required=True, help=\"Base path for CMS\")\n    parser.add_argument(\"--test\", action=\"store_true\", help=\"Run integration tests\")\n    \n    args = parser.parse_args()\n    \n    # Initialize integration\n    config = create_integration_config()\n    integration = CMSIntegration(args.base_path, config)\n    \n    if args.test:\n        print(\"Running integration tests...\")\n        \n        # Test status\n        status = integration.get_cms_status()\n        print(f\"CMS Status: {json.dumps(status, indent=2)}\")\n        \n        # Test workflow\n        workflow_result = integration.process_workflow_request('course_setup', {\n            'course_info': {\n                'course_id': 'test_integration_course',\n                'course_name': 'Integration Test Course',\n                'course_code': 'INT101',\n                'academic_year': '2023',\n                'semester': 'Fall',\n                'instructor': 'Test Instructor',\n                'department': 'Computer Science'\n            }\n        })\n        \n        print(f\"Course Setup Result: {json.dumps(workflow_result, indent=2)}\")\n        \n        print(\"Integration tests completed\")\n    \n    integration.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()"