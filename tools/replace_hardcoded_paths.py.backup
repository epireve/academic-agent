#!/usr/bin/env python3
"""
Hardcoded Path Replacement Tool

This script updates hardcoded paths throughout the academic-agent codebase
to use the new centralized OutputManager system.

Part of the unified architecture refactoring effort.
"""

import os
import re
import shutil
from pathlib import Path
from typing import Dict, List, Tuple, Set
from dataclasses import dataclass

@dataclass
class PathReplacement:
    """Represents a path replacement operation."""
    pattern: str
    replacement: str
    import_needed: bool = True
    description: str = ""

class HardcodedPathReplacer:
    """Replaces hardcoded paths with OutputManager calls."""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.replacements_made = 0
        self.files_modified = 0
        
        # Define path replacement patterns
        self.path_replacements = [
            # SRA study notes paths
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/ai_enhanced_study_notes["\']',
                replacement='get_final_output_path(ContentType.STUDY_NOTES)',
                description="AI enhanced study notes output path"
            ),
            PathReplacement(
                pattern=r'Path\(["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/ai_enhanced_study_notes["\']\)',
                replacement='get_final_output_path(ContentType.STUDY_NOTES)',
                description="AI enhanced study notes Path object"
            ),
            
            # SRA alignment analysis paths
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/alignment_analysis["\']',
                replacement='get_analysis_output_path(ContentType.ALIGNMENT)',
                description="Alignment analysis output path"
            ),
            
            # SRA enhanced integrated notes
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/enhanced_integrated_notes["\']',
                replacement='get_processed_output_path(ContentType.ENHANCED)',
                description="Enhanced integrated notes path"
            ),
            
            # SRA integrated notes
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/integrated_notes["\']',
                replacement='get_processed_output_path(ContentType.INTEGRATED)',
                description="Integrated notes path"
            ),
            
            # SRA lectures markdown
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/lectures/markdown["\']',
                replacement='get_processed_output_path(ContentType.MARKDOWN, subdirectory="lectures")',
                description="Lectures markdown path"
            ),
            
            # SRA lectures general
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/lectures["\']',
                replacement='get_processed_output_path(ContentType.MARKDOWN, subdirectory="lectures")',
                description="Lectures output path"
            ),
            
            # SRA mermaid diagrams
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/mermaid_diagrams["\']',
                replacement='get_output_manager().get_output_path(OutputCategory.ASSETS, ContentType.DIAGRAMS, subdirectory="mermaid")',
                description="Mermaid diagrams path"
            ),
            
            # SRA notes
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/notes["\']',
                replacement='get_processed_output_path(ContentType.MARKDOWN, subdirectory="notes")',
                description="SRA notes path"
            ),
            
            # SRA resolved content
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/resolved_content["\']',
                replacement='get_processed_output_path(ContentType.RESOLVED)',
                description="Resolved content path"
            ),
            
            # SRA textbook markdown
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/textbook/markdown["\']',
                replacement='get_processed_output_path(ContentType.MARKDOWN, subdirectory="textbook")',
                description="Textbook markdown path"
            ),
            
            # SRA textbook general
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/textbook["\']',
                replacement='get_processed_output_path(ContentType.MARKDOWN, subdirectory="textbook")',
                description="Textbook output path"
            ),
            
            # SRA transcripts markdown
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/transcripts/markdown["\']',
                replacement='get_processed_output_path(ContentType.MARKDOWN, subdirectory="transcripts")',
                description="Transcripts markdown path"
            ),
            
            # SRA transcripts general
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/sra/transcripts["\']',
                replacement='get_processed_output_path(ContentType.MARKDOWN, subdirectory="transcripts")',
                description="Transcripts output path"
            ),
            
            # General output paths
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output/consolidated["\']',
                replacement='get_final_output_path(ContentType.REPORTS, subdirectory="consolidated")',
                description="Consolidated output path"
            ),
            
            # General output directory
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?output["\']',
                replacement='str(get_output_manager().outputs_dir)',
                import_needed=False,
                description="General output directory"
            ),
            
            # Path objects with project root
            PathReplacement(
                pattern=r'self\.project_root\s*/\s*["\']output["\']',
                replacement='get_output_manager().outputs_dir',
                import_needed=False,
                description="Project root output path"
            ),
            
            # Markdown directory
            PathReplacement(
                pattern=r'["\'](?:/Users/[^/]+/dev\.local/academic-agent/)?markdown["\']',
                replacement='get_processed_output_path(ContentType.MARKDOWN)',
                description="Markdown directory"
            ),
        ]
        
        # Import statements to add
        self.import_statements = [
            "from src.core.output_manager import get_output_manager, get_final_output_path, get_processed_output_path, get_analysis_output_path",
            "from src.core.output_manager import OutputCategory, ContentType"
        ]
    
    def find_python_files(self) -> List[Path]:
        """Find all Python files that need path updates."""
        python_files = []
        
        # Search in specific directories
        search_dirs = ["tools", "agents", "src", "academic-agent-v2/src"]
        
        for search_dir in search_dirs:
            dir_path = self.project_root / search_dir
            if dir_path.exists():
                for py_file in dir_path.rglob("*.py"):
                    # Skip __pycache__ and .venv files
                    if "__pycache__" not in str(py_file) and ".venv" not in str(py_file):
                        python_files.append(py_file)
        
        return python_files
    
    def has_hardcoded_paths(self, file_path: Path) -> bool:
        """Check if file contains hardcoded paths."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # Check for any hardcoded path patterns
            hardcoded_patterns = [
                r'/Users/[^/]+/dev\.local/academic-agent/output',
                r'output/sra/',
                r'"output"',
                r"'output'",
                r'Path.*output.*sra',
                r'\.project_root.*output'
            ]
            
            for pattern in hardcoded_patterns:
                if re.search(pattern, content):
                    return True
                    
            return False
            
        except Exception as e:
            print(f"Error reading {file_path}: {e}")
            return False
    
    def add_imports(self, content: str) -> str:
        """Add necessary imports to the file content."""
        lines = content.split('\n')
        import_added = False
        
        # Find the best place to add imports (after existing imports)
        insert_index = 0
        in_docstring = False
        docstring_char = None
        
        for i, line in enumerate(lines):
            stripped = line.strip()
            
            # Handle docstrings
            if not in_docstring and (stripped.startswith('"""') or stripped.startswith("'''")):
                docstring_char = stripped[:3]
                if stripped.count(docstring_char) == 1:  # Opening docstring
                    in_docstring = True
                continue
            elif in_docstring and docstring_char in line:
                in_docstring = False
                continue
            elif in_docstring:
                continue
            
            # Skip comments and empty lines
            if stripped.startswith('#') or not stripped:
                continue
                
            # If we find an import, update insert index
            if stripped.startswith(('import ', 'from ')):
                insert_index = i + 1
            elif stripped and not stripped.startswith(('import ', 'from ')):
                # We've hit non-import code, stop here
                break
        
        # Check if our imports are already present
        has_output_manager_import = any('output_manager' in line for line in lines)
        
        if not has_output_manager_import:
            # Add our imports
            if insert_index > 0:
                lines.insert(insert_index, "")
                insert_index += 1
            
            for import_stmt in self.import_statements:
                lines.insert(insert_index, import_stmt)
                insert_index += 1
            
            lines.insert(insert_index, "")
            import_added = True
        
        return '\n'.join(lines), import_added
    
    def replace_paths_in_content(self, content: str) -> Tuple[str, int]:
        """Replace hardcoded paths in file content."""
        replacements_count = 0
        
        for replacement in self.path_replacements:
            # Use re.sub to replace all occurrences
            new_content, count = re.subn(replacement.pattern, replacement.replacement, content)
            if count > 0:
                content = new_content
                replacements_count += count
                print(f"  - Replaced {count} occurrence(s) of: {replacement.description}")
        
        return content, replacements_count
    
    def process_file(self, file_path: Path, dry_run: bool = False) -> Dict[str, any]:
        """Process a single file for path replacements."""
        result = {
            "file": str(file_path),
            "replacements": 0,
            "import_added": False,
            "success": False,
            "error": None
        }
        
        try:
            # Read file content
            with open(file_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
            
            # Replace paths
            content, replacements_count = self.replace_paths_in_content(original_content)
            
            if replacements_count > 0:
                # Add imports if needed
                content, import_added = self.add_imports(content)
                
                result["replacements"] = replacements_count
                result["import_added"] = import_added
                
                if not dry_run:
                    # Create backup
                    backup_path = file_path.with_suffix(file_path.suffix + '.backup')
                    shutil.copy2(file_path, backup_path)
                    
                    # Write updated content
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(content)
                    
                    print(f"‚úÖ Updated {file_path} ({replacements_count} replacements)")
                else:
                    print(f"üìã Would update {file_path} ({replacements_count} replacements)")
                
                result["success"] = True
                self.replacements_made += replacements_count
                self.files_modified += 1
            
        except Exception as e:
            result["error"] = str(e)
            print(f"‚ùå Error processing {file_path}: {e}")
        
        return result
    
    def run_replacement(self, dry_run: bool = True) -> Dict[str, any]:
        """Run the complete path replacement process."""
        print("üîÑ Hardcoded Path Replacement Tool")
        print("=" * 50)
        print(f"Project root: {self.project_root}")
        print(f"Mode: {'DRY RUN' if dry_run else 'LIVE UPDATE'}")
        print()
        
        # Find Python files
        python_files = self.find_python_files()
        print(f"Found {len(python_files)} Python files to scan")
        
        # Filter files with hardcoded paths
        files_to_process = []
        for file_path in python_files:
            if self.has_hardcoded_paths(file_path):
                files_to_process.append(file_path)
        
        print(f"Found {len(files_to_process)} files with hardcoded paths")
        print()
        
        # Process each file
        results = []
        for file_path in files_to_process:
            print(f"Processing: {file_path.relative_to(self.project_root)}")
            result = self.process_file(file_path, dry_run)
            results.append(result)
            print()
        
        # Summary
        successful_files = [r for r in results if r["success"]]
        failed_files = [r for r in results if r["error"]]
        
        print("=" * 50)
        print("üìä REPLACEMENT SUMMARY")
        print(f"Files processed: {len(files_to_process)}")
        print(f"Files modified: {len(successful_files)}")
        print(f"Total replacements: {self.replacements_made}")
        print(f"Files with errors: {len(failed_files)}")
        
        if failed_files:
            print("\n‚ùå Files with errors:")
            for result in failed_files:
                print(f"  - {result['file']}: {result['error']}")
        
        if not dry_run and successful_files:
            print(f"\nüíæ Backup files created with .backup extension")
            print("   Review changes and remove backups when satisfied")
        
        return {
            "files_processed": len(files_to_process),
            "files_modified": len(successful_files),
            "total_replacements": self.replacements_made,
            "files_with_errors": len(failed_files),
            "results": results
        }

def main():
    """Main function to run path replacement."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Replace hardcoded paths with OutputManager calls")
    parser.add_argument("--project-root", default=".", help="Project root directory")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be changed without making changes")
    parser.add_argument("--live", action="store_true", help="Actually make the changes (opposite of dry-run)")
    
    args = parser.parse_args()
    
    # Determine if this is a dry run
    dry_run = not args.live if args.live else True
    
    project_root = Path(args.project_root).resolve()
    
    replacer = HardcodedPathReplacer(str(project_root))
    results = replacer.run_replacement(dry_run=dry_run)
    
    # Save results
    results_file = project_root / "path_replacement_results.json"
    with open(results_file, 'w') as f:
        import json
        json.dump(results, f, indent=2, default=str)
    
    print(f"\nüìÑ Results saved to: {results_file}")

if __name__ == "__main__":
    main()